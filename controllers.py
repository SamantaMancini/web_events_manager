from sqlalchemy.orm import Session
from fastapi import Depends, HTTPException
from models import Event, EventCreate, EventUpdate
from database import get_db
from datetime import timezone, datetime
from send import *

# Controller for creating a new event (POST)
def create_Event(event: EventCreate, db: Session = Depends(get_db)):
    # Add the event data from the EventCreate model to the database
    db_event = Event(name=event.name, description=event.description, street=event.street, 
                     date_event_start=event.date_event_start.astimezone(timezone.utc), date_event_end=event.date_event_end.astimezone(timezone.utc)
                    )
    # Check if the required event fields are empty and raise an exception if so
    if db_event.name == "" or db_event.description == "" or db_event.street == "":
        raise HTTPException(status_code=400, detail="Required event fields cannot be empty")
    # Check if the event start date/time is after or equal to the end date/time and raise an exception if so
    if db_event.date_event_start >= db_event.date_event_end:
        raise HTTPException(status_code=400, detail="Start date/time must be before end date/time")

    # Add the event object to the database session
    db.add(db_event)
    # Commit the changes to the database
    db.commit()
    # Refresh the event object with the values generated by the database 
    db.refresh(db_event)
    # Return the newly created event object
    return db_event

# Controller for reading all events (GET) with pagination
def read_events(skip: int = 0, limit: int = 10, db: Session = Depends(get_db)):
    # Retrieve a list of events from the database, skipping the first 'skip' elements and limiting the result to 'limit' elements
    events = db.query(Event).offset(skip).limit(limit).all()
    return events

# Controller for searching events on a specific date (GET)
def read_event(event_date: datetime, db: Session = Depends(get_db)):
    # Retrieve all events from the database where the provided date falls between the event's start and end dates
    events = db.query(Event).filter(Event.date_event_start <= event_date, Event.date_event_end >= event_date).all()
    # Check if no events were found for the specified date and raise an exception if so
    if len(events) == 0:
        raise HTTPException(status_code=404, detail="Event not found")
    # Initialize a string to hold the information of all found events
    event_string = ""
    # Iterate through the list of found events and format the information for the email
    for event in events:
        event_string += f"Titolo: {event.name},\n Descrizione: {event.description}\n, Date start: {event.date_event_start}\n, Date end: {event.date_event_end}"
    # Send an email with the list of events for the specified date
    send_mail(f"Questi sono gli eventi del giorno: {event_date}\n {event_string}")
     # Return the list of found events
    return events 
    
# Controller for updating an existing event (PUT)
def update_event(event_id: int, event: EventUpdate, db: Session=Depends(get_db)):
    # Filter the event in the database based on the provided ID
    db_event = db.query(Event).filter(Event.id == event_id).first()
    # Check if the event with the specified ID does not exist and raise an exception if so
    if db_event is None:
        raise HTTPException(status_code=404, detail="Event not found")
    # Check if the new start date/time is after or equal to the new end date/time and raise an exception if so
    if event.date_event_start >= event.date_event_end:
        raise HTTPException(status_code=400, detail="Time is wrong")
    # Update the event fields in the database with the provided data
    db_event.date_event_start = event.date_event_start
    db_event.date_event_end = event.date_event_end
    # Commit the changes to the database
    db.commit()
    # Update the event object with the new values from the database
    db.refresh(db_event)
    # Return the updated event object
    return db_event

# Controller for deleting an event (DELETE)
def delete_event(event_id: int, db: Session = Depends(get_db)):
    # Filter the event in the database based on the provided ID
    db_event = db.query(Event).filter(Event.id == event_id).first()
    # Check if the event with the specified ID does not exist and raise an exception if so
    if db_event is None:
        raise HTTPException(status_code=404, detail="Event not found")
    # Delete the event object from the database session
    db.delete(db_event)
    # Commit the changes to the database
    db.commit()
    # Return the deleted event object (it might be more appropriate to return a success status here)
    return db_event